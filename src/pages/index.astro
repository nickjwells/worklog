---
import BaseLayout from '../layouts/BaseLayout.astro';
import ProfileCard from '../components/ProfileCard.astro';
import Post from '../components/Post.astro';

import postsData from '../../data/posts.json';

const { profile, posts } = postsData;

// Type for posts
type PostType = {
  id: string;
  content: string;
  timestamp: string;
  category?: 'update' | 'thought';
  curated?: boolean;
};

// Calculate stats
const sortedPosts = [...posts].sort((a, b) =>
  new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
);

// Calculate streak (consecutive days with posts)
function calculateStreak(posts: PostType[]): number {
  if (posts.length === 0) return 0;

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const postDates = new Set(
    posts.map(p => {
      const d = new Date(p.timestamp);
      d.setHours(0, 0, 0, 0);
      return d.getTime();
    })
  );

  let streak = 0;
  let checkDate = new Date(today);

  while (true) {
    if (postDates.has(checkDate.getTime())) {
      streak++;
      checkDate.setDate(checkDate.getDate() - 1);
    } else {
      break;
    }
  }

  return streak;
}

// Calculate average posts per day
function calculateAvgPerDay(posts: PostType[]): number {
  if (posts.length < 2) return posts.length;

  const dates = posts.map(p => new Date(p.timestamp).getTime());
  const earliest = Math.min(...dates);
  const latest = Math.max(...dates);
  const daysDiff = Math.max(1, Math.ceil((latest - earliest) / (1000 * 60 * 60 * 24)));

  return Math.round((posts.length / daysDiff) * 10) / 10;
}

const streak = calculateStreak(sortedPosts);
const avgPerDay = calculateAvgPerDay(sortedPosts);
const thoughtCount = posts.filter((p: PostType) => p.category === 'thought').length;
const updateCount = posts.filter((p: PostType) => p.category === 'update').length;
const curatedCount = posts.filter((p: PostType) => p.curated).length;

// Initial posts (first 100)
const POSTS_PER_PAGE = 100;
const initialPosts = sortedPosts.slice(0, POSTS_PER_PAGE);
const totalPages = Math.ceil(sortedPosts.length / POSTS_PER_PAGE);
const hasMorePages = totalPages > 1;

// Group initial posts by month
const groupedPosts = initialPosts.reduce((groups: Record<string, PostType[]>, post: PostType) => {
  const date = new Date(post.timestamp);
  const monthYear = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  if (!groups[monthYear]) {
    groups[monthYear] = [];
  }
  groups[monthYear].push(post);
  return groups;
}, {});
---

<BaseLayout title={`${profile.name} - Work Log`}>
  <div class="max-w-2xl mx-auto px-6 py-12 sm:py-16">
    <ProfileCard
      name={profile.name}
      handle={profile.handle}
      bio={profile.bio}
      avatarUrl="/avatar.jpg"
      postCount={posts.length}
      streak={streak}
      avgPerDay={avgPerDay}
      revenue="$335K"
    />

    <!-- Filter tabs -->
    <div class="flex items-center gap-2 mt-6 mb-4 text-sm" id="filter-tabs">
      <button
        class="filter-btn px-3 py-1.5 rounded-full active"
        data-filter="all"
      >
        All ({posts.length})
      </button>
      <button
        class="filter-btn px-3 py-1.5 rounded-full"
        data-filter="update"
      >
        Updates ({updateCount})
      </button>
      <button
        class="filter-btn px-3 py-1.5 rounded-full"
        data-filter="thought"
      >
        Thoughts ({thoughtCount})
      </button>
      <button
        class="filter-btn px-3 py-1.5 rounded-full"
        data-filter="curated"
      >
        Curated ({curatedCount})
      </button>
    </div>

    <div id="posts-container">
      {Object.entries(groupedPosts).map(([monthYear, monthPosts]) => (
        <section class="mt-8 month-section" data-month={monthYear}>
          <h2 class="text-2xl font-semibold tracking-tight pb-4" style="color: var(--color-text-primary); border-bottom: 1px solid var(--color-border-strong);">
            {monthYear}
          </h2>
          <div>
            {monthPosts.map((post: PostType) => (
              <Post
                content={post.content}
                timestamp={post.timestamp}
                category={post.category || 'update'}
                curated={post.curated || false}
              />
            ))}
          </div>
        </section>
      ))}
    </div>

    {hasMorePages && (
      <div id="load-more-trigger" class="py-8 text-center loading-text">
        <span id="loading-text">Scroll for more...</span>
      </div>
    )}

    {posts.length === 0 && (
      <p class="text-center py-16 empty-text">
        No updates yet.
      </p>
    )}
  </div>

  <script define:vars={{ totalPages }}>
    window.__totalPages = totalPages;
  </script>

  <script>
    // Linkify helper (same as Post.astro)
    function linkify(text: string): string {
      const urlPattern = /(https?:\/\/[^\s<]+)/g;
      return text.replace(urlPattern, (url) => {
        let cleanUrl = url;
        const trailingPunct = /[).,!?;:'"]+$/;
        const match = cleanUrl.match(trailingPunct);
        const trailing = match ? match[0] : '';
        cleanUrl = cleanUrl.replace(trailingPunct, '');
        return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer" class="post-link">${cleanUrl}</a>${trailing}`;
      });
    }

    // Format date helper
    function formatDate(timestamp: string): string {
      const date = new Date(timestamp);
      return date.toLocaleDateString('en-US', {
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });
    }

    // Get month/year string
    function getMonthYear(timestamp: string): string {
      const date = new Date(timestamp);
      return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
    }

    // Create post HTML
    function createPostHTML(post: any): string {
      const categoryLabel = post.category === 'thought' ? 'Thought' : 'Update';
      const categoryClass = post.category === 'thought' ? 'category-thought' : 'category-update';
      const curatedBadge = post.curated
        ? '<span class="text-xs px-2 py-0.5 rounded-full curated-badge">Curated</span>'
        : '';

      return `
        <article class="py-8 post-article" data-category="${post.category || 'update'}" data-curated="${post.curated || false}">
          <div class="flex items-center gap-2 mb-2">
            <p class="text-xs font-medium tracking-wide uppercase ${categoryClass}">${categoryLabel}</p>
            ${curatedBadge}
          </div>
          <h2 class="text-2xl font-semibold leading-tight tracking-tight whitespace-pre-line post-content">${linkify(post.content)}</h2>
          <time datetime="${post.timestamp}" class="text-sm mt-3 block post-time">${formatDate(post.timestamp)}</time>
        </article>
      `;
    }

    // Infinite scroll logic
    let currentPage = 1;
    let isLoading = false;
    let currentFilter = 'all';
    const totalPages = (window as any).__totalPages || 1;

    const container = document.getElementById('posts-container');
    const trigger = document.getElementById('load-more-trigger');
    const loadingText = document.getElementById('loading-text');

    async function loadMorePosts() {
      if (isLoading || currentPage >= totalPages) return;
      isLoading = true;
      currentPage++;

      if (loadingText) loadingText.textContent = 'Loading...';

      try {
        const response = await fetch(`/api/${currentPage}.json`);
        const data = await response.json();

        data.posts.forEach((post: any) => {
          const monthYear = getMonthYear(post.timestamp);
          let section = container?.querySelector(`[data-month="${monthYear}"]`);

          // Create month section if it doesn't exist
          if (!section) {
            section = document.createElement('section');
            section.className = 'mt-8 month-section';
            section.setAttribute('data-month', monthYear);
            section.innerHTML = `
              <h2 class="text-2xl font-semibold tracking-tight pb-4" style="color: var(--color-text-primary); border-bottom: 1px solid var(--color-border-strong);">${monthYear}</h2>
              <div></div>
            `;
            container?.appendChild(section);
          }

          // Add post to section
          const postsDiv = section.querySelector('div');
          if (postsDiv) {
            postsDiv.insertAdjacentHTML('beforeend', createPostHTML(post));
          }
        });

        // Apply current filter to new posts
        if (currentFilter !== 'all') {
          applyFilter(currentFilter);
        }

        if (!data.hasMore) {
          if (trigger) trigger.style.display = 'none';
        } else if (loadingText) {
          loadingText.textContent = 'Scroll for more...';
        }
      } catch (error) {
        console.error('Failed to load posts:', error);
        if (loadingText) loadingText.textContent = 'Failed to load. Scroll to retry.';
      }

      isLoading = false;
    }

    // Intersection Observer for infinite scroll
    if (trigger) {
      const observer = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) {
          loadMorePosts();
        }
      }, { rootMargin: '200px' });

      observer.observe(trigger);
    }

    // Filter functionality
    function applyFilter(filter: string) {
      const posts = document.querySelectorAll('[data-category]');
      const monthSections = document.querySelectorAll('.month-section');

      posts.forEach(post => {
        const category = post.getAttribute('data-category');
        const curated = post.getAttribute('data-curated') === 'true';

        let show = false;
        if (filter === 'all') show = true;
        else if (filter === 'curated') show = curated;
        else if (filter === category) show = true;

        (post as HTMLElement).style.display = show ? 'block' : 'none';
      });

      monthSections.forEach(section => {
        const visiblePosts = section.querySelectorAll('[data-category]:not([style*="display: none"])');
        (section as HTMLElement).style.display = visiblePosts.length > 0 ? 'block' : 'none';
      });
    }

    const filterBtns = document.querySelectorAll('.filter-btn');
    filterBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const filter = btn.getAttribute('data-filter') || 'all';
        currentFilter = filter;

        // Update button styles
        filterBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        applyFilter(filter);
      });
    });
  </script>
</BaseLayout>

<style>
  .filter-btn {
    background-color: var(--color-btn-secondary-bg);
    color: var(--color-btn-secondary-text);
    transition: background-color 0.15s ease, color 0.15s ease;
  }
  .filter-btn:hover:not(.active) {
    background-color: var(--color-btn-secondary-hover);
  }
  .filter-btn.active {
    background-color: var(--color-btn-primary-bg);
    color: var(--color-btn-primary-text);
  }
  .month-header {
    color: var(--color-text-primary);
    border-bottom: 1px solid var(--color-border-strong);
  }
  .loading-text {
    color: var(--color-text-secondary);
  }
  .empty-text {
    color: var(--color-text-secondary);
  }
  /* Dynamic post styles (for infinite scroll) */
  .post-article {
    border-bottom: 1px solid var(--color-border);
  }
  .post-content {
    color: var(--color-text-primary);
  }
  .post-time {
    color: var(--color-text-secondary);
  }
  .category-thought {
    color: var(--color-accent);
  }
  .category-update {
    color: var(--color-text-secondary);
  }
  .curated-badge {
    background-color: var(--color-bg-tertiary);
    color: var(--color-text-primary);
  }
  .post-link {
    color: var(--color-accent);
  }
  .post-link:hover {
    text-decoration: underline;
  }
</style>
